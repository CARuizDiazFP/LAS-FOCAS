# Nombre de archivo: 2026-01-09.md
# Ubicación de archivo: docs/PR/2026-01-09.md
# Descripción: Registro diario de cambios del 2026-01-09

# PR Diario — 2026-01-09

## Resumen de cambios

Sesión con múltiples focos:
1. **Smart Search** para el dashboard de Infraestructura
2. **Corrección de healthcheck** en el script de arranque
3. **UX del Modal de Conflictos** para carga de trackings
4. **Nuevas opciones de gestión** de rutas de FO

### 1. Smart Search para Infraestructura

Conversión del sistema de búsqueda de "Search Builder con filtros tipados" a **Smart Search con texto libre**:

**Backend:**
- Nuevo endpoint `POST /api/infra/smart-search` en `web/web_app/main.py`
- Modelo `SmartSearchRequestModel` con `terms: list[str]`, `limit`, `offset`
- Lógica de búsqueda: cada término se busca en múltiples campos (nombre, dirección, fontine_id, servicios, cables, estado, origen)
- Términos se combinan con **AND** (intersección)

**Frontend:**
- Input único de texto libre reemplaza el combo select + input
- Sistema de **tags/términos** visuales con botón × para eliminar
- Quick chips actualizados con `data-term` para agregar términos predefinidos
- Búsqueda se dispara al presionar botón "Buscar" o agregar término desde chip

**Estilos:**
- Nuevas clases CSS: `.infra-search-input`, `.infra-search-terms`, `.infra-search-term`
- Animación `tagIn` para feedback visual al agregar términos

### 2. Fix de Camara.cables

- Agregada propiedad `@property def cables()` al modelo `Camara` en `db/models/infra.py`
- Retorna `cables_origen + cables_destino` (unifica ambas relaciones)
- Resuelve `AttributeError: 'Camara' object has no attribute 'cables'`

### 3. Fix de Health Check en Start Script

**Problema:** El health check de WEB fallaba por timeout aunque el servicio estaba funcionando.

**Diagnóstico:**
- Web service bound a IP `192.168.241.28:8080` (no `0.0.0.0`)
- Reglas de firewall (iptables) bloquean acceso a puerto 8080 excepto desde subredes específicas
- `curl http://localhost:8080/health` desde el host era bloqueado
- `curl` desde DENTRO del contenedor funcionaba correctamente

**Solución:**
- Cambio en `Start` script: usar `check_internal` en lugar de `check_http_dual` para WEB
- `check_internal` ejecuta `docker exec` para hacer curl desde dentro del contenedor

### 4. Actualización de Dependencias

- `python-docx`: 0.8.11 → **1.1.2** (fix de compatibilidad)
- `staticmap`: 0.5.5 → **0.5.7**
- Archivos actualizados: `requirements.txt`, `api/requirements.txt`, `web/requirements.txt`, `bot_telegram/requirements.txt`

## Contexto y alcance

- **Módulo afectado:** Infraestructura FO, Script de arranque
- **Objetivo:** Simplificar la UX de búsqueda de cámaras con texto libre intuitivo
- **Restricciones:** Mantener compatibilidad con endpoints existentes

## Archivos modificados

| Archivo | Cambio |
|---------|--------|
| `db/models/infra.py` | Agregada propiedad `cables` en modelo `Camara` |
| `web/web_app/main.py` | Nuevo endpoint `POST /api/infra/smart-search` |
| `web/templates/panel.html` | UI de Smart Search (input único + terms container) |
| `web/static/panel.js` | Lógica de `searchTerms[]`, `addTerm()`, `removeTerm()` |
| `web/static/styles.css` | Estilos para Smart Search |
| `Start` | Cambio de `check_http_dual` a `check_internal` para WEB |
| `requirements.txt` | python-docx, staticmap actualizados |
| `api/requirements.txt` | python-docx actualizado |
| `web/requirements.txt` | python-docx, staticmap actualizados |
| `bot_telegram/requirements.txt` | python-docx actualizado |

## Tareas realizadas

- [x] Agregar propiedad `Camara.cables` al modelo
- [x] Crear endpoint `POST /api/infra/smart-search` en web service
- [x] Actualizar UI de panel.html para Smart Search
- [x] Actualizar panel.js con lógica de términos
- [x] Actualizar styles.css con estilos de Smart Search
- [x] Diagnosticar falla de health check de WEB en Start
- [x] Aplicar fix usando `check_internal` para WEB
- [x] Verificar todos los health checks pasan
- [x] Actualizar dependencias python-docx y staticmap
- [x] Rebuild y deploy de servicios

## Tareas pendientes

- [ ] Tests unitarios para endpoint smart-search
- [ ] Documentar endpoint smart-search en docs/api.md
- [ ] Probar Smart Search con datos reales en producción
- [ ] Evaluar si agregar debounce al input de búsqueda

## Criterios de aceptación

- ✅ Smart Search permite agregar múltiples términos de texto libre
- ✅ Términos se muestran como tags con opción de eliminar
- ✅ Búsqueda devuelve cámaras que coinciden con TODOS los términos
- ✅ Quick chips agregan términos predefinidos
- ✅ Health checks de Start pasan para todos los servicios
- ✅ Docker images construyen sin errores de dependencias

## Validación manual

```bash
# Health checks
./Start --no-down
# Output: OK WEB (interno web -> http://localhost:8080/health)
#         OK API (...), OK NLP_INTENT (...), OK DB (...)

# Smart Search (desde browser)
# 1. Agregar término "LIBRE" → clic en Buscar
# 2. Agregar término "corrientes" → clic en Buscar
# 3. Resultado: cámaras que contienen "LIBRE" Y "corrientes"
```

## Impacto en seguridad

- Sin cambios en autenticación
- El endpoint smart-search requiere sesión activa (`_require_auth`)
- El fix de health check no expone nuevos puertos

## Compatibilidad

- Endpoint `/api/infra/search` (filtros AND) sigue funcionando
- Endpoint `/api/infra/camaras` (búsqueda simple) sigue funcionando
- Smart Search es una alternativa más simple, no un reemplazo

## Próximos pasos

1. Probar Smart Search con archivos de tracking reales
2. Agregar tests para el nuevo endpoint
3. Considerar autocompletado/sugerencias basado en datos existentes
4. Documentar el endpoint en docs/api.md
---

## Parte 2: UX del Modal de Conflictos de Tracking

### Problemas detectados

1. **Modal se abría automáticamente** al iniciar la página y no permitía cerrarse
2. **Faltaba opción "Complementar"** (MERGE_APPEND) para agregar cámaras sin eliminar las existentes
3. **Etiqueta incorrecta**: "Crear Backup" debía ser "Camino disjunto"
4. **Faltaba botón "Limpiar servicio"** para eliminar asociaciones de empalmes desde el frontend

### Causa raíz del bug del modal

El JavaScript usaba **optional chaining** (`?.`) en la inicialización del modal:

```javascript
// ANTES (Problemático)
const trackingModal = document.getElementById('tracking-conflict-modal');
trackingModal?.classList.remove('active');  // No fallaba pero no inicializaba correctamente
```

El problema: cuando el modal aún no existía en el DOM al momento de cargar el script, la referencia quedaba en estado inconsistente, provocando que se mostrara apenas se agregaba al DOM.

```javascript
// DESPUÉS (Correcto)
const trackingModal = document.getElementById('tracking-conflict-modal');
if (trackingModal) {
    trackingModal.classList.remove('active');
}
```

### Correcciones aplicadas

#### 1. Corrección de inicialización del modal (panel.js)

- Eliminado uso de optional chaining (`?.`) en referencias al modal
- Agregados chequeos explícitos `if (trackingModal)` antes de cada operación
- Funciones `showConflictModal()`, `closeConflictModal()`, `selectAction()` ahora validan existencia del modal

#### 2. Nueva opción MERGE_APPEND (panel.html)

Agregado botón para complementar el camino actual sin eliminar empalmes existentes:

```html
<button class="btn subtle" data-action="MERGE_APPEND">
  <svg>...</svg> Complementar (sumar cámaras)
</button>
```

#### 3. Renombrado de "Crear Backup" a "Camino disjunto"

Refleja mejor el propósito: crear un camino alternativo/disjunto, no un backup de datos.

#### 4. Botón "Limpiar servicio" (panel.html + panel.js)

Nuevo botón con icono de papelera junto al dropzone de trackings:

```html
<button id="infra-clear-service-btn" class="btn infra-clear-btn" title="Quitar todas las cámaras asociadas al servicio">
  <svg><!-- Icono papelera --></svg>
</button>
```

Funcionalidad JavaScript:
```javascript
async function clearServiceEmpalmes() {
    const servicioId = prompt('Ingresá el ID del servicio (ej: 52547):');
    if (!servicioId) return;
    if (!confirm(`¿Confirmar eliminación de TODOS los empalmes del servicio ${servicioId}?`)) return;
    
    const response = await fetch(`${API_BASE}/api/infra/servicios/${servicioId}/empalmes`, {
        method: 'DELETE',
        headers: { 'X-CSRF-Token': CSRF_TOKEN }
    });
    // ...manejo de respuesta
}
```

#### 5. Estilos para botón de limpieza (styles.css)

```css
.infra-clear-btn {
    background: rgba(220, 53, 69, 0.1);
    border: 1px solid rgba(220, 53, 69, 0.3);
    color: #dc3545;
    padding: 0.5rem;
    border-radius: 6px;
    cursor: pointer;
    transition: all 0.2s ease;
}
.infra-clear-btn:hover {
    background: rgba(220, 53, 69, 0.2);
    border-color: rgba(220, 53, 69, 0.5);
}
```

### Backend: Acción MERGE_APPEND (ya implementada)

La acción `MERGE_APPEND` ya estaba implementada en `core/services/infra_service.py`:

```python
def _action_merge_append(self, parsed, topologia, content_hash, filename, raw_content, target_ruta_id):
    """MERGE_APPEND: Agrega empalmes nuevos a una ruta existente sin borrar los actuales."""
    # 1. Obtiene empalmes existentes de la ruta
    # 2. Por cada empalme nuevo:
    #    - Crea cámara si no existe
    #    - Crea empalme si no existe
    #    - Solo asocia a la ruta si NO está ya asociado (evita duplicados)
    # 3. Actualiza hash y timestamp de la ruta
```

El endpoint `/api/infra/trackings/resolve` ya soporta la acción.

### Archivos modificados (Parte 2)

| Archivo | Cambio |
|---------|--------|
| `web/templates/panel.html` | Agregado botón MERGE_APPEND, renombrado a "Camino disjunto", agregado botón "Limpiar servicio" |
| `web/static/panel.js` | Fix de inicialización del modal, función `clearServiceEmpalmes()`, actionLabels actualizado |
| `web/static/styles.css` | Estilos `.infra-clear-btn` para botón de limpieza |

### Tareas realizadas (Parte 2)

- [x] Diagnosticar bug de modal que se abría automáticamente
- [x] Corregir inicialización del modal (eliminar optional chaining)
- [x] Agregar opción MERGE_APPEND con botón "Complementar"
- [x] Renombrar "Crear Backup" a "Camino disjunto"
- [x] Agregar botón "Limpiar servicio" con icono papelera
- [x] Implementar función `clearServiceEmpalmes()` en JavaScript
- [x] Agregar estilos CSS para botón de limpieza
- [x] Copiar archivos actualizados a contenedores
- [x] Reiniciar servicio web

### Criterios de aceptación (Parte 2)

- ✅ Modal NO se abre automáticamente al cargar la página
- ✅ Modal se cierra correctamente con botón ×
- ✅ Opción "Complementar (sumar cámaras)" disponible
- ✅ Etiqueta "Camino disjunto" en lugar de "Crear Backup"
- ✅ Botón "Limpiar servicio" visible junto al dropzone
- ✅ Confirmación doble antes de eliminar empalmes (prompt + confirm)

### Validación manual (Parte 2)

```bash
# Verificar archivos desplegados
docker exec lasfocas-web cat /app/templates/panel.html | grep -A2 "MERGE_APPEND"
docker exec lasfocas-web cat /app/static/panel.js | grep "clearServiceEmpalmes"

# En el navegador:
# 1. Ir a Infraestructura
# 2. Verificar que el modal NO aparezca
# 3. Seleccionar servicio y subir tracking
# 4. Verificar opciones del modal: Reemplazar, Complementar, Camino disjunto, Ignorar
# 5. Probar botón "Limpiar servicio" (papelera roja)
```

---

## Resumen consolidado del día

### Mejoras implementadas

1. **Smart Search**: Búsqueda por texto libre con términos múltiples (AND)
2. **Health Check Fix**: Verificación interna desde contenedor
3. **Modal de Conflictos**: Corrección de UX y nuevas opciones
4. **Gestión de Rutas FO**: 
   - MERGE_APPEND para complementar sin eliminar
   - "Camino disjunto" (antes Backup)
   - Botón para limpiar asociaciones de servicio

### Flujo completo de Tracking ahora soporta

| Escenario | Acción | Resultado |
|-----------|--------|-----------|
| Servicio nuevo | CREATE_NEW | Crea servicio + ruta "Principal" |
| Tracking idéntico | SKIP | No hace nada (hash coincide) |
| Tracking diferente | REPLACE | Reemplaza empalmes de ruta activa |
| Tracking diferente | MERGE_APPEND | Agrega empalmes sin eliminar existentes |
| Tracking diferente | BRANCH | Crea nueva ruta "Camino disjunto" |
| Limpieza manual | DELETE empalmes | Desasocia todas las cámaras del servicio |

### Próximos pasos

1. Probar flujo completo con archivos de tracking reales
2. Agregar tests unitarios para Smart Search
3. Documentar API de infraestructura en docs/api.md
4. Evaluar autocompletado en Smart Search
5. Considerar historial de cambios por ruta (audit trail)