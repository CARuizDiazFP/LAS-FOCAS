# Nombre de archivo: Start
# Ubicación de archivo: Start
# Descripción: Script mejorado para reiniciar stack mínimo (DB, NLP, API, Web, Office) con validaciones y healthchecks internos. IP fija 192.168.241.28 requerida en VM.

#!/usr/bin/env bash
set -euo pipefail

# Colores simples
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m'

ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
COMPOSE_FILE="$ROOT_DIR/deploy/compose.yml"
COMPOSE_BASE=(docker compose -f "$COMPOSE_FILE" --env-file "$ROOT_DIR/.env")

HOST_IP="192.168.241.28" # Requerido según infraestructura de la VM

SERVICES=(postgres nlp_intent api web office)
CRITICAL=(postgres api web nlp_intent office)

DO_DOWN=true
PURGE=false
REBUILD_FRONTEND=false
REBUILD_API=false
NO_COLOR=false

usage() {
  cat <<EOF
Uso: ./Start [opciones]

Opciones:
  --no-down             No ejecutar 'docker compose down' previo (reutiliza contenedores existentes)
  --purge               Down + elimina volúmenes e imágenes locales de servicios mínimos
  --rebuild-frontend    Fuerza rebuild sin cache de la imagen web (frontend npm)
  --rebuild-api         Fuerza rebuild sin cache de la imagen de la API
  --no-color            Deshabilita colores en salida
  -h, --help            Muestra esta ayuda

Ejemplos:
  ./Start                 Reinicia limpio y levanta stack mínimo
  ./Start --rebuild-frontend  Fuerza recompilación del frontend
  ./Start --rebuild-api       Fuerza recompilación de la API
  ./Start --purge         Reinicio completo (pierde datos de DB)
EOF
}

while [[ $# -gt 0 ]]; do
  case "$1" in
    --no-down) DO_DOWN=false ;;
    --purge) PURGE=true ;;
    --rebuild-frontend) REBUILD_FRONTEND=true ;;
    --rebuild-api) REBUILD_API=true ;;
    --no-color) NO_COLOR=true ;;
    -h|--help) usage; exit 0 ;;
    *) echo -e "${YELLOW}Opción desconocida: $1${NC}"; usage; exit 1 ;;
  esac
  shift
done

if $NO_COLOR; then GREEN=''; YELLOW=''; RED=''; NC=''; fi

echo -e "${GREEN}=== LAS-FOCAS :: Start (stack mínimo) ===${NC}"

########################################
# 1) Verificaciones rápidas del host   #
########################################
command -v docker >/dev/null 2>&1 || { echo -e "${RED}Docker no está instalado en el PATH${NC}"; exit 1; }
if ! docker compose version >/dev/null 2>&1; then
  echo -e "${RED}No se encontró 'docker compose' plugin (v2).${NC}"; exit 1
fi

if [ ! -f "$ROOT_DIR/.env" ]; then
  echo -e "${YELLOW}No existe .env en la raíz. Creando desde deploy/env.sample...${NC}"
  cp "$ROOT_DIR/deploy/env.sample" "$ROOT_DIR/.env"
  echo -e "${YELLOW}Revisá y ajustá credenciales en .env antes de producción.${NC}"
fi

########################################
# 2) Reinicio / Limpieza                #
########################################
if $DO_DOWN; then
  echo -e "${GREEN}Deteniendo stack anterior...${NC}"
  if $PURGE; then
    echo -e "${YELLOW}PURGE activado: se eliminarán volúmenes e imágenes locales de servicios mínimos.${NC}"
    "${COMPOSE_BASE[@]}" down -v --remove-orphans || true
    # Limpieza de imágenes locales (scope limitado a nombre de proyecto lasfocas)
    for s in "${SERVICES[@]}"; do
      img_id=$(docker images --format '{{.Repository}}:{{.Tag}} {{.ID}}' | awk '/lasfocas/ && /'"$s"'/ {print $2}' | head -n1)
      if [ -n "$img_id" ]; then docker rmi "$img_id" >/dev/null 2>&1 || true; fi
    done
  else
    "${COMPOSE_BASE[@]}" down --remove-orphans || true
  fi
fi

########################################
# 3) Build & Up                         #
########################################
UP_CMD=("${COMPOSE_BASE[@]}" up -d --build)
if $REBUILD_FRONTEND; then
  echo -e "${YELLOW}Forzando rebuild sin cache para servicio web (frontend)...${NC}"
  "${COMPOSE_BASE[@]}" build --no-cache web
fi

echo -e "${GREEN}Levantando servicios mínimos: ${SERVICES[*]}${NC}"
"${UP_CMD[@]}" "${SERVICES[@]}"

########################################
# 3.5) Migraciones Alembic              #
########################################
# Ejecutar migraciones dentro del contenedor de la API, usando las variables
# de entorno ya definidas en .env y la url de alembic/env.py (DATABASE_URL/ALEMBIC_URL)
echo -e "${GREEN}Ejecutando migraciones Alembic...${NC}"
# Espera activa con límite para Postgres healthy (evita bloqueos)
MAX_TRIES=40
DELAY=3
for i in $(seq 1 $MAX_TRIES); do
  status=$(docker inspect -f '{{.State.Health.Status}}' lasfocas-postgres 2>/dev/null || echo "unknown")
  if [ "$status" = "healthy" ]; then
    echo -e "${GREEN}Postgres healthy.${NC}"
    break
  fi
  echo -e "${YELLOW}Esperando Postgres (estado: $status) $i/$MAX_TRIES...${NC}"
  sleep $DELAY
done

# Construir ALEMBIC_URL desde .env si existe
set +u
source "$ROOT_DIR/.env" >/dev/null 2>&1 || true
set -u
ALEMBIC_URL="postgresql+psycopg://${POSTGRES_USER:-lasfocas}:${POSTGRES_PASSWORD:-superseguro}@${POSTGRES_HOST:-postgres}:${POSTGRES_PORT:-5432}/${POSTGRES_DB:-lasfocas}"

MIG_OK=false
if $REBUILD_API; then
  echo -e "${YELLOW}Forzando rebuild sin cache para servicio API...${NC}"
  "${COMPOSE_BASE[@]}" build --no-cache api
fi
for i in $(seq 1 5); do
  # Usar el contenedor API ya iniciado para evitar diferencias de entorno de `run`
  if "${COMPOSE_BASE[@]}" exec -T api sh -lc "ALEMBIC_URL='$ALEMBIC_URL' alembic -c /app/db/alembic.ini upgrade head"; then
    MIG_OK=true
    echo -e "${GREEN}Migraciones aplicadas correctamente.${NC}"
    break
  else
    echo -e "${YELLOW}Intento de migración $i/5 fallido. Reintentando en 4s...${NC}"
    sleep 4
  fi
done
if [ "$MIG_OK" != true ]; then
  echo -e "${RED}No se pudieron aplicar las migraciones Alembic.${NC}"
  exit 2
fi

########################################
# 4) Health checks                      #
########################################
declare -A HEALTH_RESULTS

check_http() {
  local name="$1" url="$2" max=30 delay=3
  for i in $(seq 1 $max); do
    if curl -fsS "$url" >/dev/null 2>&1; then
      echo -e "${GREEN}OK${NC} $name -> $url"
      HEALTH_RESULTS[$name]=OK
      return 0
    fi
    echo -e "${YELLOW}Esperando $name (externo) $i/$max...${NC}"; sleep "$delay"
  done
  echo -e "${RED}Timeout $name (${url})${NC}"; HEALTH_RESULTS[$name]=FAIL; return 1
}

# Fallback: intenta localhost primero y si falla reintenta con IP fija
check_http_dual() {
  local name="$1" primary="$2" fallback="$3" max=30 delay=3
  for i in $(seq 1 $max); do
    if curl -fsS "$primary" >/dev/null 2>&1; then
      echo -e "${GREEN}OK${NC} $name -> $primary"
      HEALTH_RESULTS[$name]=OK; return 0
    fi
    # A partir del intento 6 probar también fallback
    if [ $i -ge 6 ]; then
      if curl -fsS "$fallback" >/dev/null 2>&1; then
        echo -e "${GREEN}OK${NC} $name -> $fallback (fallback)"
        HEALTH_RESULTS[$name]=OK; return 0
      fi
    fi
    echo -e "${YELLOW}Esperando $name (dual) $i/$max...${NC}"; sleep "$delay"
  done
  echo -e "${RED}Timeout $name (${primary} / ${fallback})${NC}"; HEALTH_RESULTS[$name]=FAIL; return 1
}

# Chequeo interno usando Python (urllib) dentro del contenedor, evita dependencia de curl
check_internal() {
  local name="$1" service="$2" url="$3" max=30 delay=3
  for i in $(seq 1 $max); do
    if "${COMPOSE_BASE[@]}" exec -T "$service" python - "$url" <<'PY' >/dev/null 2>&1; then
import sys, urllib.request
url = sys.argv[1]
try:
    with urllib.request.urlopen(url, timeout=5) as r:
        if r.status == 200:
            sys.exit(0)
except Exception:
    pass
sys.exit(1)
PY
      echo -e "${GREEN}OK${NC} $name (interno $service -> $url)"
      HEALTH_RESULTS[$name]=OK; return 0
    fi
    echo -e "${YELLOW}Esperando $name (interno) $i/$max...${NC}"; sleep "$delay"
  done
  echo -e "${RED}Timeout $name (interno $service -> $url)${NC}"; HEALTH_RESULTS[$name]=FAIL; return 1
}

echo -e "${GREEN}Comprobando health de servicios...${NC}"
check_http    "API"        "http://localhost:8001/health" || true
# WEB: usar check interno porque el puerto 8080 está bindeado solo a IP fija y firewall bloquea acceso local
check_internal "WEB"        "web"  "http://localhost:8080/health" || true
check_internal "NLP"        "nlp_intent"  "http://localhost:8100/health" || true
check_internal "LibreOffice" "office"     "http://localhost:8090/health" || true

# Ollama externo (warning si falla)
if curl -fsS http://localhost:11434/api/tags >/dev/null 2>&1; then
  echo -e "${GREEN}OK${NC} Ollama externo"; HEALTH_RESULTS[Ollama]=OK
else
  echo -e "${YELLOW}WARN${NC} Ollama no respondió en http://localhost:11434 (modo degradado NLP)"; HEALTH_RESULTS[Ollama]=WARN
fi

########################################
# 5) Resumen                            #
########################################
echo -e "\n${GREEN}Resumen de health:${NC}"
FAIL_COUNT=0
for comp in API WEB NLP LibreOffice; do
  state=${HEALTH_RESULTS[$comp]:-FAIL}
  if [ "$state" = "OK" ]; then
    echo -e "  $comp: ${GREEN}OK${NC}"
  else
    echo -e "  $comp: ${RED}FAIL${NC}"; ((FAIL_COUNT++)) || true
  fi
done
echo -e "  Ollama: ${HEALTH_RESULTS[Ollama]:-NOCHK}"

if [ $FAIL_COUNT -gt 0 ]; then
  echo -e "${RED}Uno o más servicios críticos no pasaron health. Revisar logs con:${NC}"
  echo "  docker compose -f deploy/compose.yml logs -f"
  exit 2
fi

echo -e "${GREEN}Listo.${NC} UI: http://$HOST_IP:8080/  |  API: http://localhost:8001/docs"
echo -e "${YELLOW}Nota:${NC} IP fija forzada ($HOST_IP). Ollama externo en :11434."
